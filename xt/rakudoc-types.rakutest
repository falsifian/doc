#!/usr/bin/env raku

=begin overview

When referring to items that are types, the required format is:

   L<C<Thing>|/type/Thing>

Any other formatting code that refers to a type will fail the test; any C<>
that isn't inside of an L<> will fail, and any L<> that doesn't have a C<>
will fail.

=end overview

use Test;
use lib $*PROGRAM.parent(2).child('lib');

use Test-Files;
use Pod::Convenience;

my @files = Test-Files.pods;

if @files {
    plan +@files;
} else {
    plan :skip-all<No rakudoc files specified>
}

sub render-node($node) {
    my $type = $node.contents.join('');
    my $result = $node.type ~ '<' ~ $type;
    if $node.type eq 'L' {
        $result ~= '|' ~ $node.meta
    }
    $result ~= '>';
    
    $result;
}

sub is-valid-type($node, $parent) {
    # only care about I<>, C<>, L<>, etc.
    return unless $node ~~ Pod::FormattingCode;

    # Does this match a type?
    my $type = $node.contents.join('').subst('::','/', :g);
    return unless "doc/Type/$type.rakudoc".IO.f;

    # Might be nested but we only report on the innermost here.
    if $node.type ne 'C' {
        flunk "{render-node($node)} should be L<C<$type>|/type/$type>";
        return;
    }

    # Probably in a paragraph
    if $parent === Nil or ! ($parent ~~  Pod::FormattingCode) {
        flunk "{render-node($node)} should be L<C<$type>|/type/$type>";
        return;
    }

    # Wrapped, but not in an L<>
    if $parent.type ne 'L' {
        flunk "$parent.type<{render-node($node)}> should be L<C<$type>|/type/$type> - bad parent FormattingCode";
        return;
    } elsif $parent.meta ne "/type/$type" {
        # Wrapped in an L<> but wrong URL
        flunk "L<{render-node($node)}|$parent.meta> should be L<C<$type>|/type/$type> - bad link";
    } else {
        # \o/
        pass "$type reference correctly formatted.";
    }
}

sub walk-content($item, $parent) {
    is-valid-type($item, $parent);

    next unless $item.can('contents');
    for @($item.contents) -> $child {
        walk-content($child, $item);
    }
}

# Walk through pod on each file.
for @files -> $file {
    my @chunks = extract-pod($file).contents;

    # This emits pass or flunk for each local L<> found.
    subtest $file => {
        walk-content($_, Nil) for @chunks;
    }
}
