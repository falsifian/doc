#!/usr/bin/env raku

=begin overview

When referring to items that are types, the required format is:

   L<C<Thing>|/type/Thing>

Any other formatting code that refers to a type will fail the test; any C<>
that isn't inside of an L<> will fail, and any L<> that doesn't have a C<>
will fail.

=end overview

use Test;
use lib $*PROGRAM.parent(2).child('lib');

use Test-Files;
use Pod::Convenience;

my @files = Test-Files.pods;

if @files {
    plan +@files;
} else {
    plan :skip-all<No rakudoc files specified>
}

sub is-valid-type($node, $parent) {
    # only care about I<>, C<>, L<>, etc.
    return unless $node ~~ Pod::FormattingCode;

    # Does this match a type?
    my $type = $node.contents.join('').subst('::','/', :g);
    return unless "doc/Type/$type.rakudoc".IO.f;

    if $node.type ne 'C' {
        flunk $node.type ~ '<' ~ $type ~ "> should be L<C<$type>|/type/$type>";
        return;
    }

    if $parent === Nil or ! ($parent ~~  Pod::FormattingCode) {
        flunk $node.type ~ '<' ~ $type ~ "> should be L<C<$type>|/type/$type> - bad parent class: {$parent.^name}";
        return;
    }

    if $parent.type ne 'L' {
        flunk $parent.type ~ '<C<' ~ $type ~ ">> should be L<C<$type>|/type/$type> - bad parent FormattingCode";
        return;
    } elsif $parent.meta ne "/type/$type" {
        flunk 'L<C<' ~ $type ~ '|' ~ $parent.meta~ ">> should be L<C<$type>|/type/$type> - bad link";
    } else {
        pass "$type reference correctly formatted.";
    }

}

sub walk-content($item, $parent) {
    is-valid-type($item, $parent);

    next unless $item.can('contents');
    for @($item.contents) -> $child {
        walk-content($child, $item);
    }
}

for @files -> $file {
    my @chunks = extract-pod($file).contents;

    # This emits pass or flunk for each local L<> found.
    subtest $file => {
        walk-content($_, Nil) for @chunks;
    }
}
